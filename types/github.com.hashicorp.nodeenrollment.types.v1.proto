syntax = "proto3";

option go_package = "github.com/hashicorp/nodeenrollment/types";

package github.com.hashicorp.nodeenrollment.types.v1;

import "google/protobuf/timestamp.proto";

// KEYTYPE is an enum holding known key types
enum KEYTYPE {
  UNSPECIFIED = 0;
  ED25519 = 1;
  X25519 = 2;
}

// CertificateBundle contains information about a certificate the its issuing
// certificate
message CertificateBundle {
  bytes certificate_der = 1 [json_name="certificate_der"];
  bytes ca_certificate_der = 2 [json_name="ca_certificate_der"];
  google.protobuf.Timestamp certificate_not_before = 7 [json_name="certificate_not_before"];
  google.protobuf.Timestamp certificate_not_after = 8 [json_name="certificate_not_after"];
}

// RootCertificate contains information about a root CA certificate and its
// associated public/private keys
message RootCertificate {
  string id = 1; // "current" or "next"
  bytes public_key_pkix = 2 [json_name="public_key_pkix"];
  bytes private_key_pkcs8 = 4 [json_name="private_key_pkcs8"];
  KEYTYPE private_key_type = 5 [json_name="private_key_type"];
  bytes certificate_der = 6 [json_name="certificate_der"];
  google.protobuf.Timestamp not_before = 7 [json_name="not_before"];
  google.protobuf.Timestamp not_after = 8 [json_name="not_after"];

  // If set, the key ID of the wrapping key used to encrypt the private key
  string wrapping_key_id = 30 [json_name="wrapping_key_id"];
}

// RootCertificates is a message that holds two root certificates for easy
// usage/identification.
message RootCertificates {
  RootCertificate current = 1;
  RootCertificate next = 2;
}

// NodeInformation contains server-side information about a node: its
// certificate public key, any issued certificates (purely for informational
// purposes), its encryption public key and the corresponding server private
// key. Nonce may or may not have a value depending on the flow used to register
// the node and the current state of that flow. The first seen value can be
// useful for display to an operator looking to authorize a node. Authorized
// stores whether or not this node is authorized; technically we could derive
// this based on whether we have complete key/certificate information, but it's
// nice to be explicit.
//
// The ID corresponds to a key identifier generated by this library's
// KeyIdFromPkix function; unlike RootCertificate or NodeCredentials, which will
// only have at most two active values, here we need to identify an incoming
// node's information so use the actual key ID. Rotation simply means a new
// entry will be added with the new ID.
message NodeInformation {
  string id = 1;
  bytes certificate_public_key_pkix = 2 [json_name="certificate_public_key_pkix"];
  KEYTYPE certificate_public_key_type = 3 [json_name="certificate_public_key_type"];
  repeated CertificateBundle certificate_bundles = 6 [json_name="certificate_bundles"];

  bytes encryption_public_key_bytes = 10 [json_name="encryption_public_key_bytes"];
  KEYTYPE encryption_public_key_type = 11 [json_name="encryption_public_key_type"];
  bytes server_encryption_private_key_bytes = 12 [json_name="server_encryption_private_key_bytes"];
  KEYTYPE server_encryption_private_key_type = 13 [json_name="server_encryption_private_key_type"];

  bytes registration_nonce = 20 [json_name="registration_nonce"];
  google.protobuf.Timestamp first_seen = 22 [json_name="first_seen"];
  bool authorized = 23;

  // If set, the key ID of the wrapping key used to encrypt the private key and
  // the nonce
  string wrapping_key_id = 30 [json_name="wrapping_key_id"];
}

// NodeCredentials is the corresponding struct for NodeInformation on the node
// side, containing the values necessary for proving identity. At various points
// in registration/authorization flows this may have some or all fields filled in.
message NodeCredentials {
  string id = 1; // "current" or "next"
  bytes certificate_public_key_pkix = 2 [json_name="certificate_public_key_pkix"];
  bytes certificate_private_key_pkcs8 = 4 [json_name="certificate_private_key_pkcs8"];
  KEYTYPE certificate_private_key_type = 5 [json_name="certificate_private_key_type"];
  repeated CertificateBundle certificate_bundles = 6 [json_name="certificate_bundles"];

  bytes encryption_private_key_bytes = 10 [json_name="encryption_private_key_bytes"];
  KEYTYPE encryption_private_key_type = 11 [json_name="encryption_private_key_type"];

  bytes server_encryption_public_key_bytes = 12 [json_name="server_encryption_public_key_bytes"];
  KEYTYPE server_encryption_public_key_type = 13 [json_name="server_encryption_public_key_type"];

  bytes registration_nonce = 20 [json_name="registration_nonce"];

  // If set, the key ID of the wrapping key used to encrypt the private keys
  string wrapping_key_id = 30 [json_name="wrapping_key_id"];
}

// FetchNodeCredentialsInfo contains the values bundled and signed into a
// FetchNodeCredentialsRequest. These values contain the ID (for identification,
// although the server should always re-derive this itself), the claimed
// certificate public key (which is also used to sign these values), and the
// public encryption key, as well as the registration nonce.
//
// Because the signature from the certificate public key is across both itself
// and the encryption key, if the key ID is authorized, then after verification
// of the signature we can trust the public encryption key too, which is an
// important property for preventing MITM/replay scenarios.
message FetchNodeCredentialsInfo {
  string id = 1; // Key id derived from pkix public key

  bytes certificate_public_key_pkix = 2 [json_name="certificate_public_key_pkix"];
  KEYTYPE certificate_public_key_type = 3 [json_name="certificate_public_key_type"];

  bytes encryption_public_key_bytes = 10 [json_name="encryption_public_key_bytes"];
  KEYTYPE encryption_public_key_type = 11 [json_name="encryption_public_key_type"];

  bytes nonce = 20;
}

// FetchNodeCredentialsRequest contains the marshaled FetchNodeCredentialsInfo
// message and a signature using private key corresponding to the certificate
// public key contained within the marshaled bundle.
message FetchNodeCredentialsRequest {
  bytes bundle = 28;
  bytes bundle_signature = 29 [json_name="bundle_signature"];
}

// FetchNodeCredentialsResponse contains a response to a fetch request. If
// unauthorized, only that bool will be returned. If authorized, the encrypted
// node credentials will contain a marshaled NodeCredentials struct containing
// certificates and other server-provided information, with the encryption key
// derived from a DH operation on the node's submitted public key and the
// server's private key corresponding to the given public encryption key.
//
// The encrypted node credentials are signed with the current root certificate
// key. This is an optional step that can be taken by the node if it has
// pre-distributed CA certificates to validate the signature on the encrypted
// node credentials. This mostly is a guard against the failure of an operator
// to actually validate the key ID that they are authorizing.
message FetchNodeCredentialsResponse {
  bytes server_encryption_public_key_bytes = 12 [json_name="encryption_public_key_bytes"];
  KEYTYPE server_encryption_public_key_type = 13 [json_name="encryption_public_key_type"];

  bool authorized = 23;

  bytes encrypted_node_credentials = 40 [json_name="encrypted_node_credentials"];
  bytes encrypted_node_credentials_signature = 41 [json_name="encrypted_node_credentials_signature"];
}

// GenerateServerCertificatesRequest holds values necessary for the server to
// generate a server-side TLS certificate, either for itself or for a middle
// node in a multi-hop scenario. The nonce and signature are provided by the
// authenticating node, so that the server can validate the signature and ensure
// that the node is authorized, then embed the nonce in the returned certificate
// to authorize the upstream node (or server) to the authenticating node.
//
// The common name and skip verification parameters would ideally be options to
// downstream functions, however, since multihop goes over gRPC (or could go
// over some other transport) the options cannot be carried in that way. If
// desired, in the future, an options message could be created and these (and
// any other) values aggregated there.
message GenerateServerCertificatesRequest {
  bytes certificate_public_key_pkix = 2 [json_name="certificate_public_key_pkix"];
  bytes nonce = 20;
  bytes nonce_signature = 21 [json_name="nonce_signature"];
  string common_name = 24 [json_name="common_name"];
  bool skip_verification = 25 [json_name="skip_verification"];
}

// GenerateServerCertificatesResponse contains values for a successful response
// to the request: a private key for the server (or intemediate node) to use
// along with the returned certificates.
message GenerateServerCertificatesResponse {
  bytes certificate_private_key_pkcs8 = 4 [json_name="certificate_private_key_pkcs8"];
  KEYTYPE certificate_private_key_type = 5 [json_name="certificate_private_key_type"];
  repeated CertificateBundle certificate_bundles = 6 [json_name="certificate_bundles"];
}

// OperatorLedRegistrationRequest is a request for the "operator-led"
// registration flow. Although currently empty it's required to ensure that we
// can add parameters later without an API change.
message OperatorLedRegistrationRequest {
}